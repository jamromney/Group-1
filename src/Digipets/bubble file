ArrayList<Dragable> dragables = new ArrayList<>();
int createDragable () { //returns index of dragable in dragables
  Dragable d = new Dragable();
  dragables.add(d);
  return dragables.size() - 1;
}

void setup() {
  size(600, 600);
  background(255);
  frameRate(60);
  helv = createFont("Helvetica-Bold", 90);

  // Grabage Can
  can = loadImage("garbageCan.png");
  can.resize(80, 80);

  // Bath
  bath[0] = new Bath(230, 150, 500, 500, #29A7D3, #29A7D3, #29A7D3);

  // Toy
  toy[0] = new Toy(50, 30);
  // Food

  // Pet
  color c1 = color(255, 255, 255);
  color c2 = color(255, 255, 255);
  color c3 = color(255, 255, 255);
  pet1 = new Pet(300, 300, 1, c1, c2, c3);

  // Food
  //food1 = new Food(100, 40);

  // Buttons
  btnStart = new Button("Play!", 230, 280, 160, 50);
  btnPause = new Button("Pause", 40, 540, 160, 50);
  btnEnd = new Button("End", 40, 540, 160, 50);
  btnRestart = new Button("Resume", 250, 540, 160, 50);
  btnMenu = new Button("Menu", 120, 340, 160, 50);
}

void draw() {
  background(255);

  for (Dragable d : dragables) {
  }

  switch(screen) {
  case 's':
    drawStart();
    break;
  case 'p':
    drawPlay();
    break;
  case 'e':
    drawEnd();
    break;
  case 'm':
    drawMenu();
    break;
    //case 'g'
    //  drawGameOver();
    //  break;
  }
}

void drawStart() {
  background(100, 100, 255);
  btnStart.display();
  btnMenu.display();
  fill(230);
  textSize(80);
  textFont(helv);
  text("Digipets", 310, 180);
}

void drawGameOver() {
  rectMode(CENTER);
  fill(0, 50, 0);
  rect(width/2, height/2, 600, 600);
  ellipseMode(CENTER);
  strokeWeight(0);
  fill(0, 100, 0);
  ellipse(width/2, height/2, 600, 500);
  fill(0, 150, 0);
  ellipse(width/2, height/2, 400, 300);
  fill(0);
  textMode(CENTER);
  textSize(87);
  text("GAME OVER", width/2, height/2-3);
  text(":(", width/2-2, height*3/4-4);
  fill(255, 255, 0);
  textSize(87);
  text("GAME OVER", width/2 + 3, height/2);
  text(":(", width/2, height*3/4);
}

void drawEnd() {
  background(100, 100, 255);
  btnEnd.display();
  btnRestart.display();
}

void drawMenu() {
  background(100, 100, 255);
  btnEnd.display();
  btnRestart.display();
}
void drawPlay() {
  // Background
  fill(#627FD3);
  rect(0, 520, width, height);

  // Timer
  if (millis() - lastTime >= interval) {
    println("Event triggered!");
    waste.add(new Waste(pet1.x - 50, pet1.y + 20));
    lastTime = millis(); // reset timer
  }

  // Bath class
  for (int i=0; i<bath.length; i++) {
    bath[i].display();
    if (bath[i].hover(mouseX, mouseY)) {
      bath[i].makeBubbles();
    }
  }



  // waste class
  for (int i = 0; i < waste.size(); i++) {
    Waste w = waste.get(i);
    if (w.hover(mouseX, mouseY)) {
      break;
    }
  }
  for (int i = 0; i < waste.size(); i++) {
    Waste w = waste.get(i);
    w.display();
  }

  // Garbage Can
  imageMode(CENTER);
  image(can, 250, 50);
  // bath class
  for (int i=0; i<bath.length; i++) {
    bath[i].display();
  }
  for (int i=0; i<toy.length; i++) {
    toy[i].display();
    //toy[i].bounce();
  }
  pet1.display();
  pet1.move(mouseX, mouseY);
  //food1.display();
  btnPause.display();
}

void mousePressed() {
  switch(screen) {
  case 'p':
    if (btnEnd.clicked()) {
      screen = 'e';
      break;
    }
    switch(screen) {
    case 'g':
      //if(btnGameOver.clicked()) {
      //  screen = 'g';
      //  break;
      //}
    }
  case 's':
    if (btnStart.clicked()) {
      screen = 'p';
      break;
    } else if (btnMenu.clicked()) {
      screen = 'm';
      break;
    }
    break;
  case 'e':
    if (btnEnd.clicked()) {
      screen = 's';
      break;
    }
  case 'm':
    if (btnMenu.clicked()) {
      screen = 's';
      break;
    }
    if (btnRestart.clicked()) {
      screen = 'p';
      break;
    }
  }
}
void mouseClicked() {
  for (Dragable d : dragables) {
    if (d.mouseOver()) {
      d.dragged = true;
    }
  }
}



 Bath(int x, int y, int w, int h, color c1, color c2, color c3) {
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = h;

    bath = loadImage("bath.png");
    bath.resize(200, 200);
  }

  void display() {
    image(bath, x, y);

    // draw bubbles
    for (int i = bubbles.size()-1; i >= 0; i--) {
      Bubble b = bubbles.get(i);
      b.update();
      b.display();

      if (b.isOffScreen(y)) {
        bubbles.remove(i);
      }
    }
  }

  void makeBubbles() {
    if (frameCount % 10 == 0) {
      float bx = x + bath.width * 0.3 + random(bath.width * 0.4);
      float by = y + bath.height * 0.6;
      bubbles.add(new Bubble(bx, by));
    }
  }

  boolean hover(int mx, int my) {
    return mx > x && mx < x + bath.width &&
           my > y && my < y + bath.height;
  }
}
class Bubble {
  float x, y, size, speed;

  Bubble(float x, float y) {
    this.x = x;
    this.y = y;
    this.size = random(5, 15);
    this.speed = random(0.5, 1);
  }

  void update() {
    y -= speed;
  }

  void display() {
    noFill();
    stroke(0);
    strokeWeight(2);
    ellipse(x, y, size, size);
  }

  boolean isOffScreen(float limitY) {
    return y < limitY;
  }
}
